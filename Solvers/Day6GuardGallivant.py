class Day6GuardGallivant:
    def solvePart1(self, input_value: list[str]) -> int:
        return (move := lambda position, rotation, puzzle_map: move((lambda position, rotation, puzzle_map: tuple([position[i] + rotation[i] * (lambda position, rotation, puzzle_map: len("".join([(puzzle_map[position[0]+rotation[0]*i][position[1]+rotation[1]*i]) for i in range(max(len(puzzle_map), len(puzzle_map[0]))) if 0 <= position[0]+rotation[0]*i < len(puzzle_map) and 0 <= position[1]+rotation[1]*i < len(puzzle_map[0])]).split("#")[0]) - 1)(position, rotation, puzzle_map) for i in [0, 1]]))(position, rotation, puzzle_map), (lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])(rotation), (lambda position, rotation, puzzle_map, between_coords: [["X" if (ri, ci) in between_coords else puzzle_map[ri][ci] for ci in range(len(puzzle_map[ri]))] for ri in range(len(puzzle_map))])(position, rotation, puzzle_map, (lambda position, rotation, puzzle_map, next_position: (sum([[(ri, ci) for ci in range(position[1], next_position[1] + (1 if rotation[1] > 0 else -1), 1 if rotation[1] > 0 else -1)] for ri in (range(position[0], next_position[0]+ (1 if rotation[0] > 0 else -1) , 1 if rotation[0] > 0 else -1))], start=[])))(position, rotation, puzzle_map, (lambda position, rotation, puzzle_map: tuple([position[i] + rotation[i] * (lambda position, rotation, puzzle_map: len("".join([(puzzle_map[position[0]+rotation[0]*i][position[1]+rotation[1]*i]) for i in range(max(len(puzzle_map), len(puzzle_map[0]))) if 0 <= position[0]+rotation[0]*i < len(puzzle_map) and 0 <= position[1]+rotation[1]*i < len(puzzle_map[0])]).split("#")[0]) - 1)(position, rotation, puzzle_map) for i in [0, 1]]))(position, rotation, puzzle_map)))) if (lambda position, rotation, puzzle_map: -1 < position[0] + rotation[0] < len(puzzle_map) and -1 < position[1] + rotation[1] < len(puzzle_map[0]))(position, (lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])((lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])((lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])(rotation))), puzzle_map) else (lambda puzzle_map: sum([sum([1 for col in row if col == "X"]) for row in puzzle_map]))(puzzle_map))([(ri, input_value[ri].index("^")) for ri in range(len(input_value)) if "^" in input_value[ri]][0], (-1, 0), [[col for col in row] for row in input_value])

    def solvePart2(self, input_value: list[str]) -> int:
        return (lambda new_puzzle_maps: sum([1 for i in range(len(new_puzzle_maps)) if print(f"Progress: {i+1}/{len(new_puzzle_maps)} ({round(i/(len(new_puzzle_maps)-1),4)*100}%)") or (move := lambda position, rotation, puzzle_map, previous_count, turns_without_increase: move((lambda position, rotation, puzzle_map: tuple([position[i] + rotation[i] * (lambda position, rotation, puzzle_map: len("".join([(puzzle_map[position[0]+rotation[0]*i][position[1]+rotation[1]*i]) for i in range(max(len(puzzle_map), len(puzzle_map[0]))) if 0 <= position[0]+rotation[0]*i < len(puzzle_map) and 0 <= position[1]+rotation[1]*i < len(puzzle_map[0])]).split("#")[0]) - 1)(position, rotation, puzzle_map) for i in [0, 1]]))(position, rotation, puzzle_map), (lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])(rotation), (lambda position, rotation, puzzle_map, between_coords: [["X" if (ri, ci) in between_coords else puzzle_map[ri][ci] for ci in range(len(puzzle_map[ri]))] for ri in range(len(puzzle_map))])(position, rotation, puzzle_map, (lambda position, rotation, puzzle_map, next_position: (sum([[(ri, ci) for ci in range(position[1], next_position[1] + (1 if rotation[1] > 0 else -1), 1 if rotation[1] > 0 else -1)] for ri in (range(position[0], next_position[0]+ (1 if rotation[0] > 0 else -1) , 1 if rotation[0] > 0 else -1))], start=[])))(position, rotation, puzzle_map, (lambda position, rotation, puzzle_map: tuple([position[i] + rotation[i] * (lambda position, rotation, puzzle_map: len("".join([(puzzle_map[position[0]+rotation[0]*i][position[1]+rotation[1]*i]) for i in range(max(len(puzzle_map), len(puzzle_map[0]))) if 0 <= position[0]+rotation[0]*i < len(puzzle_map) and 0 <= position[1]+rotation[1]*i < len(puzzle_map[0])]).split("#")[0]) - 1)(position, rotation, puzzle_map) for i in [0, 1]]))(position, rotation, puzzle_map))), (lambda puzzle_map: sum([sum([1 for col in row if col == "X"]) for row in puzzle_map]))(puzzle_map), turns_without_increase + ((lambda puzzle_map: sum([sum([1 for col in row if col == "X"]) for row in puzzle_map]))(puzzle_map) == previous_count)) if (lambda position, rotation, puzzle_map: -1 < position[0] + rotation[0] < len(puzzle_map) and -1 < position[1] + rotation[1] < len(puzzle_map[0]))(position, (lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])((lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])((lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])(rotation))), puzzle_map) and turns_without_increase < 4 else (lambda position, rotation, puzzle_map: -1 < position[0] + rotation[0] < len(puzzle_map) and -1 < position[1] + rotation[1] < len(puzzle_map[0]))(position, (lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])((lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])((lambda rotation : {(-1, 0): (0, 1), (0, 1): (1, 0), (1, 0): (0, -1), (0, -1): (-1, 0)}[rotation])(rotation))), puzzle_map))([(ri, input_value[ri].index("^")) for ri in range(len(input_value)) if "^" in input_value[ri]][0], (-1, 0), new_puzzle_maps[i], 0, 0)]))((lambda puzzle_map, position: sum([[(lambda coords, puzzle_map: [["#" if (ri, ci) == coords else puzzle_map[ri][ci] for ci in range(len(puzzle_map[0]))] for ri in range(len(puzzle_map))])((ri, ci), puzzle_map) for ci in range(len(puzzle_map[0])) if (ri, ci) != position and puzzle_map[ri][ci] != "#"] for ri in range(len(puzzle_map))], start=[]))([[col for col in row] for row in input_value], [(ri, input_value[ri].index("^")) for ri in range(len(input_value)) if "^" in input_value[ri]][0]))
